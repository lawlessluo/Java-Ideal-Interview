# 1. 存储引擎相关

## 1.1  介绍 MyISAM 和 InnoDB

首先 MyISAM 是 MySQL 5.5 版本前的默认数据库引擎，由早期的 ISAM（Indexed Sequential Access Method：有索引的顺序访问方法） 改良而来，虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但 MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。

InnoDB（事务性数据库索引） 是在 MySQL 5.5 版本后的一种新数据库引擎，因其对于数据完整性、并发、事务、安全等方面做出了支持，所以就逐渐取代了 MyISAM  的地位。

不过在一些读密集的场景下，MyISAM  的性能也是非常出色，而 InnoDB 更适合写密集的表。不过使用 MyISAM 的前提就是你要能接收其缺点。

### 1.1.1 MyISAM 和 InnoDB 的区别是什么？

注：部分条陈参考自：[MyISAM与InnoDB 的区别（9个不同点）](https://blog.csdn.net/qq_35642036/article/details/82820178)

- **MyISAM 采用表级锁。InnoDB 支持行级锁和表级锁，默认为行级锁。**
- **MyISAM 不支持事务，而 InnoDB 支持事务，这是一个很关键的区别。**
  - InnoDB 每一条 SQL 都默认封装成事务，自动提交，会对速度有一定影响，最好使用多条 SQL 组成一个事务
- **MyISAM 不支持外键，而 InnoDB 支持**
- **MyISAM 使用一个变量保存表的行数，速度很快，而 InnoDB 查询表的行数需要全表扫描**

- **MyISAM 是非聚簇索引，InnoDB 为聚簇索引（下面会专点讲解）**
- **InnoDB 支持 MVCC，应对高并发事务时，它比只加锁更加高效。**

#### 1.1.1.1 表级锁和行级锁的区别

- **表级锁：** 表级锁，即对当前操作的整张表加锁，是 MySQL 中锁定粒度最大的一种锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。一个更新语句会锁住整张表，其他的查询和更新都会被阻塞，因此触发锁冲突的概率最高，并发访问也受限。
- **行级锁：** 行级锁，即只针对当前操作的行进行加锁，是 MySQL 中锁定粒度最小的一种锁， 行级锁能大大减少数据库操作的冲突，提高并发性能，但加锁的开销也最大，可能会出现死锁。 
  - InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。也就是说，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。

#### 1.1.1.2 InnoDB存储引擎的锁的算法有三种

- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 锁定一个范围，包含记录本身
  - InnoDB 查询行就是用 Next-key lock 算法
  - Next-key lock 算法可以解决幻读问题，这也正是在 InnoDB 在 REPEATABLE-READ（可重复读） 下可以达到 SERIALIZABLE（可串行化） 隔离等级的原因
  - 如果查询的索引含有唯一索引的属性时，将 Next-key lock 降级为 Record key

#### 1.1.1.3 MyISAM 使用一个变量保存表的行数，为什么 InnoDB 没有？

 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询

#### 1.1.1.4 如何选择 MyISAM 和 InnoDB ？

- 如果必须要求支持事务，就选择 InnoDB，如果不需要也可以考虑 MyISAM
- 绝大部分都是读操作，可以选择 MyISAM，如果写操作也不少，选择 InnoDB
- 如果不能接受崩溃后的恢复困难问题，请选择 InnoDB

### 1.1.2 MySQL 中索引的数据结构

MySQL中的索引主要分为 **哈希索引** 和 **BTree 索引**，其背后的数据结构分别为 **哈希表** 和 **B+Tree**。

- 根据其特点：一般来说，查询单条记录的时候，哈希索引最快，但是在一般场景下，还是以 BTree 索引居多。

在 MyISAM 和 InnoDB 两种存储引擎中，两种存储引擎的实现方式不同

- MyISAM：B+Tree 叶节点的 data 域存放数据记录的地址。检索索引的时候，如果能获取到 key 则取出 data 域中的这个地址，然后再根据这个地址去读取相应的数据。
- InnoDB：B+Tree 叶节点的 data 域存放的是完整的数据记录。索引的 key 就是数据表的主键。其他索引都是辅助索引，其叶子节点的 date 域存储的是主键的值而不是地址。
  - 根据主键搜索的时候，直接找到 key 所在的节点即可取出数据，在根据辅助索引查找的时候，需要先取出主键的值，再走一遍主索引。

**1.1.2.1 什么是聚簇索引？什么是非聚簇索引？**

- 如果找到索引就可以找到数据，就是聚簇索引
- 如果索引的存储和数据的存储是分离的，也就是找到索引但是没有找到数据，需要根据索引上的值再次回查数据。

# 2. 字符集和校对规则

- 字符集：它是一种从二进制编码到某类字符符号的映射。

- 校对规则：它是指某种字符集下的排序规则。

MySQL 中每个数据库和每张数据表都有自己的默认值，如果数据表没有指定字符集，会默认使用上一层，即所属数据库的字符集。

# 3. 事务相关

## 3.1 事务的四大特征

1. **原子性**：表示事务是不可分割的最小操作单位，事务要么同时成功，要么同时失败。
2. **持久性**：当事务提交或回滚后，数据库会持久化的保存数据。
3. **隔离性**：多个事务之间。相互独立。
4. **一致性**：事务操作前后，数据总量不变

## 3.2 并发带来的事务问题

1. 脏读：一个事务，读取到另一个事务中还没有提交的数据，这个数据就是 “脏数据” ，依据此数据做出的操作可能是有问题的。
2. 幻读：一个事务先读取了一些数据，接着另一个事务插入插入了一些数据，原先的事务再读取数据的时候，发现多了一些不知道从哪里来的数据，就像是幻读了一般。
3. 不可重复读（虚读）：一个事务先读取了一些数据，接着另一个事务修改了这些数据，原先事务再次读取这些数据的时候，发现在同一个事务中，两次读取到的数据不一样。
4. 丢失修改：一个事务读取一个数据的时候，另一个事务也同时读取了，第一个事务做出修改动作，随之第二个事务也做出修改动作，这样第一个事务的操作会被第二个事务的操作覆盖掉，也叫作丢失修改。

## 3.3  事务的隔离级别

为了解决并发事务的问题，所以 SQL 标准制定了 4  个隔离级别

- **READ-UNCOMMITTED（读取未提交）**： 允许读取尚未提交的数据，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED（读取已提交）** ：允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ（可重复读）** ：除非数据是被本身事务自己所修改，否则对同一字段的多次读取结果都是一致的，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE（可串行化）** 所有的事务依次逐个执行，事务之间不会产生干扰，**该级别可以防止脏读、不可重复读以及幻读**。

上述隔离级别，从上到下，依次提高。安全性越来越高，但是锁也会越多，效率也越来越低。所以一般数据库都会选择 READ-COMMITTED（读取已提交）作为默认级别。

**特别说明**：上面提到了，InnoDB 算法，在 REPEATABLE-READ（可重复读）事务隔离级别下，使用 Next-Key Lock 锁算法，就会使得其能够阻止幻读的发生，也就是达到了 SERIALIZABLE（可串行化）的级别。

# 4. 数据库优化相关

## 4.1 大表优化

MySQL 单表记录过多的情况下，会有明显的性能下降，所以考虑做大表的优化

主要可以考虑的方向有

1. 查询时禁止不带任何限制查询，必须有一定约束，例如查询半个月的数据
2. 读写分离：主库写，从库读，分担压力。
3. 垂直分区：例如一张用户表中，有用户登录信息，还有用户资料信息，就可以拆分成两个表，甚至两个库来做
   -  优点：可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
   -  缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作。
4. 水平分区：一张表中数据过多，可以考虑做归档，例如以时间为界，3个月为划分力度，进行归档。
   - 优点：能够支持很大的数据量。
   - 缺点：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，所以水平拆分建议分库。还会存在分片问题。

## 4.2 分库分表后主键 id  如何保证唯一性？

1. 数据库自增 id 设定步长：比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。
   - 这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
2. 分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如 Twitter 的 snowflake 算法、美团的 Leaf 这种。
3. 利用 Redis 生成 id：性能不错，也灵活，但是引入新组件，加大了成本和系统复杂度。
4. 分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。

# 5. SQL 执行

##  5.1  简述一条 SQL 在 MySQL 中的执行过程（待重新整理）。 

参考： [一条SQL语句在MySQL中如何执行的](<https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd>)

